{
	"graph\\BinaryLifting" : {
		"prefix" : "graph\\BinaryLifting",
		"body" : [
			"",
			"/**",
			" * Computes LCA of two nodes in a tree in O(log N) time",
			" * Finds k^th ancestor of a node in a tree in O(log N) time",
			" * Precomputation takes O(N log N) time + O(N log N) memory",
			" * Tested on: https://judge.yosupo.jp/problem/lca",
			"*/",
			"class LCA {",
			"public:",
			"    int n, l, timer;",
			"    vector<vector<int>> adj, up;",
			"    vector <int> tin, tout;",
			"    LCA(vector<vector<int>> _adj, int root = 0) : adj(_adj) {",
			"        n = adj.size();",
			"        l = ceil(log2(n)) + 1;",
			"        timer = 0;",
			"        tin.resize(n);",
			"        tout.resize(n);",
			"        up.assign(n, vector<int>(l));",
			"        dfs(root, root, 0);",
			"    }",
			"    void dfs(int node, int prev, int d) {",
			"        tin[node] = ++timer;",
			"        up[node][0] = prev;",
			"        for(int i = 1; i < l; i++) { up[node][i] = up[up[node][i - 1]][i - 1]; }",
			"        for(auto next : adj[node]) { if(next != prev) dfs(next, node, d + 1); }",
			"        tout[node] = ++timer;",
			"    }",
			"    bool is_ancestor(int x, int y) { return tin[x] <= tin[y] && tout[x] >= tout[y]; }",
			"    int query(int u, int v) {",
			"        if(is_ancestor(u, v)) return u;",
			"        if(is_ancestor(v, u)) return v;",
			"        for(int i = l - 1; i >= 0; i--) { if(!is_ancestor(up[u][i], v)) u = up[u][i]; }",
			"        return up[u][0];",
			"    }",
			"    int jump(int x, int k) {",
			"        for(int i = l - 1; i >= 0; i--) if((k>>i) & 1) x = up[x][i];",
			"        return x;",
			"    }",
			"};",
		]
	},
	"graph\\Centroid" : {
		"prefix" : "graph\\Centroid",
		"body" : [
			"",
			"/**",
			" * Performs centroid decomposition of the tree and constructs",
			" * a new tree with O(log N) depth.",
			" * Takes O(N log N) time. ",
			"*/",
			"class Centroid {",
			"public:",
			"    int n;",
			"    vector<vector<int>> adj; // original tree",
			"    vector<int> p; // new tree, represented by parent array",
			"    vector<bool> vis;",
			"    vector <int> sz; // size of subtree, will keep changing while finding centroid decomposition",
			"",
			"    Centroid(vector<vector<int>> _adj) {",
			"        adj = _adj;",
			"        n = adj.size();",
			"        p.assign(n, -1);",
			"        vis.assign(n, false);",
			"        sz.resize(n);",
			"        init_centroid(0, -1);",
			"    }",
			"",
			"    int find_size(int node, int prev) {",
			"        sz[node] = 1;",
			"        for(auto next : adj[node]) {",
			"            if(next != prev && !vis[next]) {",
			"                sz[node] += find_size(next, node);",
			"            }",
			"        }",
			"        return sz[node];",
			"    }",
			"",
			"    int find_centroid(int node, int prev, int n) {",
			"        // n --> size of the subtree we are solving for",
			"        for(auto next : adj[node]) {",
			"            if(next != prev && !vis[next] && sz[next] > n/2) {",
			"                return find_centroid(next, node, n);",
			"            }   ",
			"        }",
			"        return node;",
			"    }",
			"",
			"    void process(int node) {",
			"        // Process node here.",
			"    }",
			"",
			"    void init_centroid(int node, int prev) {",
			"        find_size(node, prev);",
			"        int c = find_centroid(node, node, sz[node]);",
			"        process(c);",
			"        p[c] = prev;",
			"        vis[c] = true;",
			"        for(auto next : adj[c]) {",
			"            if(!vis[next]) init_centroid(next, c);",
			"        }",
			"    }",
			"};",
		]
	},
	"graph\\Dinic" : {
		"prefix" : "graph\\Dinic",
		"body" : [
			"",
			"struct FlowEdge {",
			"    int from, to;",
			"    long long cap, flow = 0;",
			"    FlowEdge(int from, int to, long long cap) : from(from), to(to), cap(cap) {}",
			"};",
			"",
			"/**",
			" * Dinic's Maximum Flow Algorithm. Runs in O(V^2 * E) time for general ",
			" * graphs (theoretically, but much faster in practice, for graphs with ",
			" * E >> V it acts more like O(V^(2/3) * E)). Runs in O(sqrt(E) * E) for ",
			" * graphs with unit capacity edges, and O(sqrt(V) * E) for bipartite graphs.",
			" * For bipartite matching or vertex cover, use BipartiteMatching class instead.",
			"*/ ",
			"class Dinic {",
			"public:",
			"    const long long FLOW_INF = 1E18;",
			"    vector<FlowEdge> edges; // Edge List of the flow graph",
			"    vector<vector<int>> adj; // Contains pointers to the edge list",
			"    int n; // Number of vertices in the graph",
			"    int m = 0; // Number of edges in the graph (Multiplied by 2, becuase we store both forward and backward edges).",
			"    int s; // source",
			"    int t; // sink",
			"    vector <int> level; // the level graph, contains level of every node in current iteration",
			"    vector <int> ptr; // optimisation to prevent backtracking from dead ends",
			"    queue <int> q; // for BFS",
			" ",
			"    Dinic(int _n, int _s, int _t) : n(_n), s(_s), t(_t) {",
			"        adj.resize(n);",
			"        level.resize(n);",
			"        ptr.resize(n);",
			"    }",
			" ",
			"    void add_edge(int from, int to, long long cap) {",
			"        edges.emplace_back(from, to, cap);",
			"        edges.emplace_back(to, from, 0);",
			"        adj[from].push_back(m);",
			"        adj[to].push_back(m + 1);",
			"        m += 2;",
			"    }",
			" ",
			"    bool bfs() {",
			"        // To get the current level graph",
			"        while(!q.empty()) {",
			"            int curr = q.front();",
			"            q.pop();",
			"            for(int id : adj[curr]) {",
			"                if(edges[id].cap - edges[id].flow < 1) continue;",
			"                if(level[edges[id].to] != -1) continue;",
			"                level[edges[id].to] = level[curr] + 1;",
			"                q.push(edges[id].to);",
			"            }",
			"        }",
			"        return level[t] != -1;",
			"    }",
			" ",
			"    long long dfs(int node, long long pushed) {",
			"        // To find a blocking flow in the current level graph",
			"        if(pushed == 0) return 0;",
			"        if(node == t) return pushed;",
			"        for(int& cid = ptr[node]; cid < (int)adj[node].size(); cid++) {",
			"            int id = adj[node][cid];",
			"            int nx = edges[id].to;",
			"            if(level[node] + 1 != level[nx] || edges[id].cap - edges[id].flow < 1) continue;",
			"            long long tr = dfs(nx, min(pushed, edges[id].cap - edges[id].flow));",
			"            if(tr == 0) continue;",
			"            edges[id].flow += tr;",
			"            edges[id ^ 1].flow -= tr;",
			"            return tr;",
			"        }",
			"        return 0;",
			"    }",
			" ",
			"    long long flow() {",
			"        // Find the maximum flow",
			"        long long f = 0;",
			"        while(true) {",
			"            fill(level.begin(), level.end(), -1);",
			"            level[s] = 0;",
			"            q.push(s);",
			"            if(!bfs()) break;",
			"            fill(ptr.begin(), ptr.end(), 0);",
			"            while(long long pushed = dfs(s, FLOW_INF)) {",
			"                f += pushed;",
			"            }",
			"        }",
			"        return f;",
			"    }",
			"",
			"    /**",
			"     * From https://usaco.guide/adv/min-cut?lang=cpp.",
			"     * Edges (a, b) connecting vertices that are reachable from the",
			"     * sourcer (lev[a] != -1) to vertices that aren't (lev[b] == -1) ",
			"     * are part of the minimum cut. ",
			"    */",
			"    vector<bool> min_cut() {",
			"        vector <bool> res(n);",
			"        for(int i = 0; i < n; i++) {",
			"            res[i] = (level[i] != -1);",
			"        }",
			"        return res;",
			"    }",
			"};",
		]
	},
	"graph\\DSU" : {
		"prefix" : "graph\\DSU",
		"body" : [
			"",
			"class DSU {",
			"public:",
			"    int n;",
			"    vector <int> p, sz;",
			"",
			"    DSU(int _n) : n(_n) {",
			"        p.resize(n);",
			"        iota(p.begin(), p.end(), 0);",
			"        sz.resize(n, 1);",
			"    }",
			"",
			"    int find(int x) {",
			"        if(x == p[x]) return x;",
			"        return p[x] = find(p[x]);",
			"    }",
			"",
			"    void unite(int a, int b) {",
			"        int c = find(a);",
			"        int d = find(b);",
			"        if(d != c) {",
			"            if(sz[c] < sz[d]) swap(c, d);",
			"            p[d] = c;",
			"            sz[c] += sz[d];",
			"        }",
			"    }",
			"};",
		]
	},
	"misc\\NextGreaterElement" : {
		"prefix" : "misc\\NextGreaterElement",
		"body" : [
			"",
			"/**",
			" * We can use a monotonic stack to find the nearest (next/previous) (smaller/greater) element for all ",
			" * elements of an array in $O(N)$ time. ",
			" * The key property of the stack is that all elements must be in (increasing/decreasing) order. ",
			" * We get $O(N)$ time complexity using amortized analysis: every element is inserted and ",
			" * removed only once from the stack.",
			"*/",
			"vector <int> previous_smaller(vector <int> &v) {",
			"    int n = v.size();",
			"    vector <int> nse(n);",
			"    stack<pair<int, int>> s; // {v[i], i}",
			"    s.push({0, -1}); // {min element, index} (Change to max element for \"greater\", Change index to n for \"next\")",
			"    for(int i = 0; i < n; i++) { // Reverse loop for \"next\"",
			"        while(s.top().first >= v[i]) s.pop(); // Change equality to <= for \"greater\"",
			"        nse[i] = s.top().second;",
			"        s.push({v[i], i});",
			"    }",
			"    return nse;",
			"}",
		]
	},
	"number-theory\\Mint" : {
		"prefix" : "number-theory\\Mint",
		"body" : [
			"",
			"const int N = 200100;",
			"const int MOD = 998244353;",
			"class Mint {",
			"public:",
			"    long long x;",
			"    Mint(long long v = 0) {",
			"        if(v < 0) v = v % MOD + MOD;",
			"        if(v >= MOD) v = v % MOD;",
			"        x = v;",
			"    }",
			"",
			"    Mint(int v) : Mint((long long)v) {}",
			"",
			"    Mint pow(long long b) const {",
			"        if(b < 0) return inv().pow(-b);",
			"        Mint a = *this;",
			"        Mint res = 1;",
			"        while(b > 0) {",
			"            if(b & 1) res *= a;",
			"            a *= a;",
			"            b >>= 1ll;",
			"        }",
			"        return res;",
			"    }",
			"",
			"    Mint inv() const { return pow(MOD - 2); }",
			"",
			"    explicit operator int() const { return x; }",
			"    explicit operator long long() const { return x; }",
			"    explicit operator bool() const { return x; }",
			"",
			"    Mint& operator+= (const Mint& other) {",
			"        x += other.x;",
			"        if(x >= MOD) x -= MOD;",
			"        return *this;",
			"    }",
			"",
			"    Mint& operator-= (const Mint& other) {",
			"        x -= other.x;",
			"        if(x < 0) x += MOD;",
			"        return *this;",
			"    }",
			"",
			"    Mint& operator*= (const Mint& other) {",
			"        x *= other.x;",
			"        x %= MOD;",
			"        return *this;",
			"    }",
			"",
			"    Mint& operator/= (const Mint& other) {",
			"        return *this *= other.inv();",
			"    }",
			"",
			"    Mint& operator++() {",
			"        return *this += 1;",
			"    }",
			"",
			"    Mint& operator--() {",
			"        return *this -= 1;",
			"    }",
			"",
			"    // https://www.cs.odu.edu/~zeil/cs333/f13/Public/faq/faq-htmlsu23.html",
			"    Mint operator++(int) {",
			"        Mint before = *this;",
			"        ++*this;",
			"        return before;",
			"    }",
			"",
			"    Mint operator--(int) {",
			"        Mint before = *this;",
			"        --*this;",
			"        return before;",
			"    }",
			"",
			"    Mint operator-() const {",
			"        return x == 0 ? 0 : MOD - x;",
			"    }",
			"",
			"    friend Mint operator+ (const Mint& a, const Mint& b) {",
			"        return Mint(a) += b;",
			"        // why not just a += b?",
			"    }",
			"",
			"    friend Mint operator- (const Mint& a, const Mint& b) { return Mint(a) -= b; }",
			"    friend Mint operator* (const Mint& a, const Mint& b) { return Mint(a) *= b; }",
			"    friend Mint operator/ (const Mint& a, const Mint& b) { return Mint(a) /= b; }",
			"",
			"    friend bool operator== (const Mint& a, const Mint& b) { return a.x == b.x; }",
			"    friend bool operator!= (const Mint& a, const Mint& b) { return a.x != b.x; }",
			"    friend bool operator< (const Mint& a, const Mint& b) { return a.x < b.x; }",
			"    friend bool operator> (const Mint& a, const Mint& b) { return a.x > b.x; }",
			"    friend bool operator<= (const Mint& a, const Mint& b) { return a.x <= b.x; }",
			"    friend bool operator>= (const Mint& a, const Mint& b) { return a.x >= b.x; }",
			"",
			"    friend ostream& operator<<(ostream& os, const Mint& m) { return os << m.x; }",
			"    friend istream& operator>>(istream& is, Mint& m) { return is >> m.x; }",
			"};",
			"",
			"vector <Mint> f(N), inv(N);",
			"",
			"void precompute_factorials() {",
			"    f[0] = 1;",
			"    for(int i = 1; i < N; i++) {",
			"        f[i] = f[i - 1] * i;",
			"    }",
			"    inv[N - 1] = f[N - 1].inv();",
			"    for(int i = N - 2; i >= 0; i--) {",
			"        inv[i] = inv[i + 1] * (i + 1);",
			"    }",
			"}",
			"",
			"Mint comb(int n, int r) {",
			"    if(n < r) return 0;",
			"    return f[n] * inv[r] * inv[n - r];",
			"}",
		]
	},
	"template" : {
		"prefix" : "template",
		"body" : [
			"#include <bits/stdc++.h>",
			"",
			"// #define int long long",
			"// #define double long double",
			"#define rep(i, a, b) for(int i = a; i < (b); i++)",
			"#define all(x) begin(x), end(x)",
			"#define sz(x) (int)(x).size()",
			"",
			"typedef long long ll;",
			"typedef pair<int, int> pi;",
			"typedef vector<int> vi;",
			"typedef vector<pair<int, int>> vpi;",
			"typedef vector<vector<int>> vvi;",
			"",
			"const int N = 200100;",
			"const int MOD = 998244353;",
			"// const int MOD = (int)1E9 + 7;",
			"const double EPS = 1E-9;",
			"",
			"void solve() {",
			"    ",
			"}",
			"",
			"int32_t main() {",
			"    cin.tie(0)->sync_with_stdio(0);",
			"    cout << setprecision(20) << fixed;",
			"",
			"    int T = 1;",
			"    cin >> T;",
			"    for(int I = 1; I <= T; I++) {",
			"        // cout << \"Case #\" << I << \": \";",
			"        solve();",
			"    }",
			"",
			"    return 0;",
			"}",
		]
	},
}
